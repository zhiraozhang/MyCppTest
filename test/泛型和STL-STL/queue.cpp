/**
 * @file queue.cpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2023-02-26
 *
 * @copyright Copyright (c) 2023
 *
 *
 * FIFO
 * push
 * pop
 * front
 * back
 * empty
 *
 * C ++迭代器用于对数据结构中的元素进行顺序访问或随机访问。
 * 因此，对于根据定义不允许顺序或随机访问的数据结构，迭代器没有任何意义。这就是堆栈和队列没有迭代器的原因。
 * 另一方面，向量和列表允许对元素进行顺序和/或随机访问，因此迭代器对于导航这些数据结构是有意义的。
 *
 * 堆栈是LIFO（后进先出）数据结构。在任何给定时间，您只能访问堆栈的顶部元素（推送到它上面的最后一个项目）。
 * 根据定义，您永远不会顺序遍历堆栈的元素，也不会使用随机访问来获取堆栈中的特定元素。您将元素放在一端，然后将元素放在同一端。
 * 您只能访问该顶级元素，并且无权访问其下方的任何内容。你可以把它想象成一堆巨大的书堆在桌子上。要到达最后一本书，您需要从顶部向下移动书籍。
 * 要添加图书，您只需将其放在顶部即可。你不能随意访问中间的书。只有您可以看到的书位于顶部。
 * 因此，堆栈没有迭代器。
 *
 * 队列是FIFO（先进先出）数据结构。在任何给定时间，您只能在一端（尾部）放置元素，并从另一端（头部）检索元素。
 * 根据定义，您永远不会顺序遍历队列的元素，也不会使用随机访问来获取队列中的特定元素。
 * 你把元素放在一端，然后从另一端拿走元素。您无法访问两端之间的任何内容。
 * 一个新人排在队列中，预约职员可以提前查看此人。不允许队列中的跳转。
 * 因此，队列没有迭代器。
 *
 * 这就是这些数据结构的行为和实现方式。您无法从中随机选择/取消选择元素。这就是为什么他们没有迭代器。
 *
 * 向量和列表支持这些随机类型的操作，这就是为什么需要迭代器。
 *
 * 而双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍也是线性结构。
 */

#include <iostream>
#include <queue>
using namespace std;

void test01()
{
    queue<int> q1;
    q1.push(1);
    q1.push(2);
    q1.push(3);
    q1.push(4);
    cout << "q1.front = " << q1.front() << " qi.back()= " << q1.back() << endl;
    q1.pop();
    cout << "出队后，" << endl
         << "q1.front = " << q1.front() << " qi.back()= " << q1.back() << endl;
    // for (queue<int>::iterator it = q1.begin(); it != q1.end(); it++)
    // {
    //     cout << *it << " ";
    // }
    // cout << endl;
}

int main()
{
    test01();
    return 0;
}